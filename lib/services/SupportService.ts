import SupportTicket, { ISupportTicket } from '@/lib/models/SupportTicket';
import SupportReply, { ISupportReply } from '@/lib/models/SupportReply';
import connectDB from '@/lib/db';

export interface CreateTicketData {
  userId: string;
  role: 'provider' | 'distributor' | 'clinic' | 'admin';
  subject: string;
  category: 'facturacion' | 'entregas' | 'producto' | 'cuenta' | 'tecnico' | 'otro';
  description: string;
  priority?: 'low' | 'medium' | 'high';
  attachments?: string[];
  tags?: string[];
}

export interface UpdateTicketData {
  subject?: string;
  category?: string;
  description?: string;
  status?: 'open' | 'in_progress' | 'resolved' | 'closed';
  priority?: 'low' | 'medium' | 'high';
  assignedTo?: string;
  tags?: string[];
  satisfactionRating?: number;
  satisfactionComment?: string;
}

export interface CreateReplyData {
  ticketId: string;
  authorId: string;
  authorRole: 'provider' | 'distributor' | 'clinic' | 'admin' | 'support';
  message: string;
  attachments?: string[];
  isInternal?: boolean;
  isAutoGenerated?: boolean;
}

export interface TicketFilters {
  userId?: string;
  status?: string;
  priority?: string;
  category?: string;
  assignedTo?: string;
  role?: string;
  search?: string;
  startDate?: Date;
  endDate?: Date;
  page?: number;
  limit?: number;
  sortBy?: 'createdAt' | 'updatedAt' | 'priority' | 'status';
  sortOrder?: 'asc' | 'desc';
}

class SupportService {
  
  // Crear un nuevo ticket
  static async createTicket(data: CreateTicketData): Promise<ISupportTicket> {
    await connectDB();
    
    const ticket = new SupportTicket({
      ...data,
      priority: data.priority || 'medium',
      status: 'open',
      lastReplyAt: new Date()
    });
    
    const savedTicket = await ticket.save();
    
    // Crear respuesta automática de confirmación
    await this.createReply({
      ticketId: savedTicket._id,
      authorId: 'system',
      authorRole: 'admin',
      message: `Hemos recibido tu solicitud de soporte. Te responderemos lo antes posible. Número de ticket: ${savedTicket._id}`,
      isAutoGenerated: true
    });
    
    return savedTicket;
  }
  
  // Obtener tickets con filtros
  static async getTickets(filters: TicketFilters = {}) {
    await connectDB();
    
    const {
      page = 1,
      limit = 20,
      sortBy = 'createdAt',
      sortOrder = 'desc',
      ...queryFilters
    } = filters;
    
    // Construir query
    const query: any = {};
    
    if (queryFilters.userId) query.userId = queryFilters.userId;
    if (queryFilters.status) query.status = queryFilters.status;
    if (queryFilters.priority) query.priority = queryFilters.priority;
    if (queryFilters.category) query.category = queryFilters.category;
    if (queryFilters.assignedTo) query.assignedTo = queryFilters.assignedTo;
    if (queryFilters.role) query.role = queryFilters.role;
    
    // Filtro de fechas
    if (queryFilters.startDate || queryFilters.endDate) {
      query.createdAt = {};
      if (queryFilters.startDate) query.createdAt.$gte = queryFilters.startDate;
      if (queryFilters.endDate) query.createdAt.$lte = queryFilters.endDate;
    }
    
    // Búsqueda de texto
    if (queryFilters.search) {
      query.$or = [
        { subject: { $regex: queryFilters.search, $options: 'i' } },
        { description: { $regex: queryFilters.search, $options: 'i' } },
        { tags: { $in: [new RegExp(queryFilters.search, 'i')] } }
      ];
    }
    
    // Ejecutar consulta
    const sortOption: any = {};
    sortOption[sortBy] = sortOrder === 'asc' ? 1 : -1;
    
    const tickets = await SupportTicket.find(query)
      .populate('userId', 'name email role')
      .populate('assignedTo', 'name email')
      .sort(sortOption)
      .skip((page - 1) * limit)
      .limit(limit);
    
    const total = await SupportTicket.countDocuments(query);
    
    // Obtener conteo de respuestas no leídas para cada ticket
    const ticketsWithUnread = await Promise.all(
      tickets.map(async (ticket) => {
        const unreadCount = await (SupportReply as any).getUnreadCount(ticket._id, ticket.userId);
        return {
          ...ticket.toObject(),
          unreadCount
        };
      })
    );
    
    return {
      tickets: ticketsWithUnread,
      pagination: {
        current: page,
        total: Math.ceil(total / limit),
        count: tickets.length,
        totalDocuments: total
      }
    };
  }
  
  // Obtener un ticket por ID
  static async getTicketById(ticketId: string, userId?: string): Promise<ISupportTicket | null> {
    await connectDB();
    
    const ticket = await SupportTicket.findById(ticketId)
      .populate('userId', 'name email role')
      .populate('assignedTo', 'name email');
    
    if (!ticket) return null;
    
    // Verificar permisos (solo el dueño o admin puede ver)
    if (userId && ticket.userId._id.toString() !== userId) {
      // Verificar si es admin/support
      // Esta verificación se debe hacer en el controlador con la sesión
    }
    
    return ticket;
  }
  
  // Actualizar un ticket
  static async updateTicket(ticketId: string, data: UpdateTicketData, updatedBy: string): Promise<ISupportTicket | null> {
    await connectDB();
    
    const ticket = await SupportTicket.findById(ticketId);
    if (!ticket) return null;
    
    // Actualizar campos
    Object.assign(ticket, data);
    
    // Si se cambia el estado a cerrado, registrar fecha
    if (data.status === 'closed') {
      ticket.closedAt = new Date();
    }
    
    const updatedTicket = await ticket.save();
    
    // Crear respuesta automática si cambió el estado
    if (data.status && data.status !== ticket.status) {
      const statusMessages = {
        'in_progress': 'Tu ticket está siendo revisado por nuestro equipo de soporte.',
        'resolved': 'Tu solicitud ha sido resuelta. Si el problema persiste, puedes reabrir este ticket.',
        'closed': 'Este ticket ha sido cerrado. Gracias por contactarnos.'
      };
      
      if (statusMessages[data.status as keyof typeof statusMessages]) {
        await this.createReply({
          ticketId,
          authorId: updatedBy,
          authorRole: 'admin',
          message: statusMessages[data.status as keyof typeof statusMessages],
          isAutoGenerated: true
        });
      }
    }
    
    return updatedTicket;
  }
  
  // Crear una respuesta
  static async createReply(data: CreateReplyData): Promise<ISupportReply> {
    await connectDB();
    
    const reply = new SupportReply(data);
    const savedReply = await reply.save();
    
    return savedReply;
  }
  
  // Obtener respuestas de un ticket
  static async getReplies(ticketId: string, includeInternal = false): Promise<ISupportReply[]> {
    await connectDB();
    
    return await (SupportReply as any).getByTicketId(ticketId, includeInternal);
  }
  
  // Marcar respuestas como leídas
  static async markRepliesAsRead(ticketId: string, userId: string): Promise<void> {
    await connectDB();
    
    await (SupportReply as any).markAsRead(ticketId, userId);
  }
  
  // Asignar ticket a un agente
  static async assignTicket(ticketId: string, assignedTo: string, assignedBy: string): Promise<ISupportTicket | null> {
    await connectDB();
    
    const ticket = await SupportTicket.findByIdAndUpdate(
      ticketId,
      { 
        assignedTo,
        status: 'in_progress'
      },
      { new: true }
    );
    
    if (!ticket) return null;
    
    // Crear nota interna
    await this.createReply({
      ticketId,
      authorId: assignedBy,
      authorRole: 'admin',
      message: `Ticket asignado para revisión.`,
      isInternal: true,
      isAutoGenerated: true
    });
    
    return ticket;
  }
  
  // Obtener estadísticas generales
  static async getStatistics() {
    await connectDB();
    
    const [generalStats, categoryStats] = await Promise.all([
      (SupportTicket as any).getStatistics(),
      (SupportTicket as any).getCategoryStats()
    ]);
    
    const recentActivity = await (SupportReply as any).getRecentActivity();
    
    return {
      general: generalStats[0] || {},
      categories: categoryStats,
      recentActivity
    };
  }
  
  // Obtener tickets pendientes para admin
  static async getPendingTickets(limit = 50) {
    await connectDB();
    
    return await SupportTicket.find({
      status: { $in: ['open', 'in_progress'] }
    })
      .populate('userId', 'name email role')
      .populate('assignedTo', 'name email')
      .sort({ priority: -1, createdAt: 1 })
      .limit(limit);
  }
  
  // Buscar tickets
  static async searchTickets(searchTerm: string, filters: TicketFilters = {}) {
    await connectDB();
    
    const searchFilters = {
      ...filters,
      search: searchTerm
    };
    
    return await this.getTickets(searchFilters);
  }
  
  // Obtener métricas de rendimiento
  static async getPerformanceMetrics(startDate?: Date, endDate?: Date) {
    await connectDB();
    
    const dateFilter: any = {};
    if (startDate || endDate) {
      dateFilter.createdAt = {};
      if (startDate) dateFilter.createdAt.$gte = startDate;
      if (endDate) dateFilter.createdAt.$lte = endDate;
    }
    
    const metrics = await SupportTicket.aggregate([
      { $match: dateFilter },
      {
        $group: {
          _id: null,
          totalTickets: { $sum: 1 },
          avgResolutionTime: {
            $avg: {
              $cond: [
                { $ne: ['$closedAt', null] },
                { $subtract: ['$closedAt', '$createdAt'] },
                null
              ]
            }
          },
          avgSatisfactionRating: { $avg: '$satisfactionRating' },
          ticketsByStatus: {
            $push: {
              status: '$status',
              priority: '$priority',
              category: '$category'
            }
          }
        }
      }
    ]);
    
    return metrics[0] || {};
  }
}

export default SupportService;
