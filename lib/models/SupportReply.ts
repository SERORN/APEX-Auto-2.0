import mongoose, { Schema, Document } from 'mongoose';

export interface ISupportReply extends Document {
  _id: string;
  ticketId: string;
  authorId: string;
  authorRole: 'provider' | 'distributor' | 'clinic' | 'admin' | 'support';
  message: string;
  attachments: string[];
  isInternal: boolean; // Para notas internas del equipo de soporte
  isAutoGenerated: boolean; // Para respuestas automáticas del sistema
  readAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

const SupportReplySchema = new Schema<ISupportReply>({
  ticketId: {
    type: String,
    required: true,
    index: true
  },
  authorId: {
    type: String,
    required: true,
    index: true
  },
  authorRole: {
    type: String,
    required: true,
    enum: ['provider', 'distributor', 'clinic', 'admin', 'support']
  },
  message: {
    type: String,
    required: true,
    maxlength: 3000,
    trim: true
  },
  attachments: [{
    type: String
  }],
  isInternal: {
    type: Boolean,
    default: false,
    index: true
  },
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  readAt: {
    type: Date
  }
}, {
  timestamps: true,
  collection: 'support_replies'
});

// Índices para consultas frecuentes
SupportReplySchema.index({ ticketId: 1, createdAt: 1 });
SupportReplySchema.index({ authorId: 1, createdAt: -1 });
SupportReplySchema.index({ ticketId: 1, isInternal: 1 });

// Middleware para actualizar el ticket cuando se agrega una respuesta
SupportReplySchema.post('save', async function(doc) {
  try {
    const SupportTicket = mongoose.model('SupportTicket');
    await SupportTicket.findByIdAndUpdate(doc.ticketId, {
      lastReplyAt: new Date(),
      $set: {
        status: doc.authorRole === 'admin' || doc.authorRole === 'support' 
          ? 'in_progress' 
          : 'open'
      }
    });
  } catch (error) {
    console.error('Error updating ticket lastReplyAt:', error);
  }
});

// Métodos estáticos
SupportReplySchema.statics.getByTicketId = function(ticketId: string, includeInternal = false) {
  const query: any = { ticketId };
  if (!includeInternal) {
    query.isInternal = { $ne: true };
  }
  
  return this.find(query)
    .populate('authorId', 'name email role')
    .sort({ createdAt: 1 });
};

SupportReplySchema.statics.getUnreadCount = function(ticketId: string, userId: string) {
  return this.countDocuments({
    ticketId,
    authorId: { $ne: userId },
    readAt: { $exists: false },
    isInternal: { $ne: true }
  });
};

SupportReplySchema.statics.markAsRead = function(ticketId: string, userId: string) {
  return this.updateMany(
    {
      ticketId,
      authorId: { $ne: userId },
      readAt: { $exists: false },
      isInternal: { $ne: true }
    },
    { readAt: new Date() }
  );
};

SupportReplySchema.statics.getRecentActivity = function(limit = 10) {
  return this.find({ isInternal: { $ne: true } })
    .populate('authorId', 'name email')
    .populate('ticketId', 'subject status')
    .sort({ createdAt: -1 })
    .limit(limit);
};

// Exportar modelo
const SupportReply = mongoose.models.SupportReply || mongoose.model<ISupportReply>('SupportReply', SupportReplySchema);

export default SupportReply;
